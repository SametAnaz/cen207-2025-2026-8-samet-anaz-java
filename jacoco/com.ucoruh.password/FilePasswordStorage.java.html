<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FilePasswordStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">password-app</a> &gt; <a href="index.source.html" class="el_package">com.ucoruh.password</a> &gt; <span class="el_source">FilePasswordStorage.java</span></div><h1>FilePasswordStorage.java</h1><pre class="source lang-java linenums">/**
 * @file FilePasswordStorage.java
 * @package com.ucoruh.password
 * @class FilePasswordStorage
 * @brief Implementation of InterfacePasswordStorage using file-based storage.
 * @author Password Manager Team
 * @version 1.0
 *
 * This class provides file-based operations to store, retrieve, update, and delete password entries.
 * All password data is encrypted using the master password.
 */
package com.ucoruh.password;

import java.io.*;
import java.util.*;

/**
 * @brief Implementation of InterfacePasswordStorage using file-based storage.
 */
public class FilePasswordStorage implements InterfacePasswordStorage {
  /**
   * @brief File name used for file-based password storage.
   *
   * This static final field holds the file name where password entries are stored
   * when using a file-based storage mechanism.
   */
  private static final String FILE = &quot;passwords.txt&quot;;

  /**
   * @brief The master password used for encryption/decryption.
   */
  private final String masterPassword;

  /**
   * @brief Constructor that initializes storage with the master password.
   *
   * @param masterPassword The master password for encryption/decryption.
   */
<span class="fc" id="L39">  public FilePasswordStorage(String masterPassword) {</span>
<span class="fc" id="L40">    this.masterPassword = masterPassword;</span>
<span class="fc" id="L41">  }</span>

  /**
   * @brief Adds a new password entry to the file-based storage.
   *
   * This method prompts the user to enter the service, username, and password, then creates a Password
   * object and appends its details to the passwords file.
   *
   * @param scanner the Scanner object used to obtain user input.
   */
  @Override
  public void add(Scanner scanner) {
<span class="fc" id="L53">    System.out.print(&quot;Service: &quot;);</span>
<span class="fc" id="L54">    String service = scanner.nextLine();</span>
<span class="fc" id="L55">    System.out.print(&quot;Username: &quot;);</span>
<span class="fc" id="L56">    String user = scanner.nextLine();</span>
<span class="fc" id="L57">    System.out.print(&quot;Password: &quot;);</span>
<span class="fc" id="L58">    String pass = scanner.nextLine();</span>
<span class="fc" id="L59">    Password p = new Password(service, user, pass);</span>
<span class="fc" id="L60">    List&lt;Password&gt; passwords = readAll();</span>
    // Check if service already exists
<span class="fc" id="L62">    boolean exists = passwords.stream()</span>
<span class="pc" id="L63">                     .anyMatch(pwd -&gt; pwd.getService().equalsIgnoreCase(service));</span>

<span class="pc bpc" id="L65" title="1 of 2 branches missed.">    if (exists) {</span>
<span class="nc" id="L66">      System.out.println(&quot;A password for this service already exists. Use update option to modify it.&quot;);</span>
<span class="nc" id="L67">      return;</span>
    }

<span class="fc" id="L70">    passwords.add(p);</span>
<span class="fc" id="L71">    writeAll(passwords);</span>
<span class="fc" id="L72">    System.out.println(&quot;Password saved successfully.&quot;);</span>
<span class="fc" id="L73">  }</span>

  /**
   * @brief Displays all stored password entries.
   *
   * This method reads all password entries from the file and prints them to the console.
   */
  @Override
  public void view() {
<span class="fc" id="L82">    List&lt;Password&gt; list = readAll();</span>

<span class="fc bfc" id="L84" title="All 2 branches covered.">    if (list.isEmpty()) {</span>
<span class="fc" id="L85">      System.out.println(&quot;No records found.&quot;);</span>
    } else {
<span class="fc bfc" id="L87" title="All 2 branches covered.">      for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="fc" id="L88">        System.out.println((i + 1) + &quot;. &quot; + list.get(i));</span>
      }
    }
<span class="fc" id="L91">  }</span>

  /**
   * @brief Updates an existing password entry.
   *
   * This method prompts the user for the service to update and, if found, updates its username and password.
   *
   * @param scanner the Scanner object used to obtain user input for the update.
   */
  @Override
  public void update(Scanner scanner) {
<span class="fc" id="L102">    List&lt;Password&gt; list = readAll();</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">    if (list.isEmpty()) {</span>
<span class="fc" id="L105">      System.out.println(&quot;No records found.&quot;);</span>
<span class="fc" id="L106">      return;</span>
    }

<span class="fc" id="L109">    System.out.print(&quot;Service to update: &quot;);</span>
<span class="fc" id="L110">    String target = scanner.nextLine();</span>
<span class="fc" id="L111">    boolean updated = false;</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">    for (Password p : list) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">      if (p.getService().equalsIgnoreCase(target)) {</span>
<span class="fc" id="L115">        System.out.print(&quot;New username (leave blank to keep current '&quot; + p.getUsername() + &quot;'): &quot;);</span>
<span class="fc" id="L116">        String username = scanner.nextLine();</span>

<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (!username.trim().isEmpty()) {</span>
<span class="fc" id="L119">          p.setUsername(username);</span>
        }

<span class="fc" id="L122">        System.out.print(&quot;New password (leave blank to keep current): &quot;);</span>
<span class="fc" id="L123">        String password = scanner.nextLine();</span>

<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (!password.trim().isEmpty()) {</span>
<span class="fc" id="L126">          p.setPassword(password);</span>
        }

<span class="fc" id="L129">        updated = true;</span>
<span class="fc" id="L130">        break;</span>
      }
<span class="fc" id="L132">    }</span>

<span class="fc bfc" id="L134" title="All 2 branches covered.">    if (updated) {</span>
<span class="fc" id="L135">      writeAll(list);</span>
<span class="fc" id="L136">      System.out.println(&quot;Password updated successfully.&quot;);</span>
    } else {
<span class="fc" id="L138">      System.out.println(&quot;Service not found.&quot;);</span>
    }
<span class="fc" id="L140">  }</span>

  /**
   * @brief Deletes a password entry from the file-based storage.
   *
   * This method prompts the user for the service name of the entry to delete and removes the entry from the file.
   *
   * @param scanner the Scanner object used to obtain user input for deletion.
   */
  @Override
  public void delete(Scanner scanner) {
<span class="fc" id="L151">    List&lt;Password&gt; list = readAll();</span>

<span class="fc bfc" id="L153" title="All 2 branches covered.">    if (list.isEmpty()) {</span>
<span class="fc" id="L154">      System.out.println(&quot;No records found.&quot;);</span>
<span class="fc" id="L155">      return;</span>
    }

<span class="fc" id="L158">    System.out.print(&quot;Service to delete: &quot;);</span>
<span class="fc" id="L159">    String target = scanner.nextLine();</span>
<span class="fc" id="L160">    boolean removed = list.removeIf(p -&gt; p.getService().equalsIgnoreCase(target));</span>

<span class="fc bfc" id="L162" title="All 2 branches covered.">    if (removed) {</span>
<span class="fc" id="L163">      writeAll(list);</span>
<span class="fc" id="L164">      System.out.println(&quot;Password deleted successfully.&quot;);</span>
    } else {
<span class="fc" id="L166">      System.out.println(&quot;Service not found.&quot;);</span>
    }
<span class="fc" id="L168">  }</span>

  /**
   * @brief Reads all password entries from the file.
   *
   * This method opens the file and reads each line, decrypts the data,
   * and converts it into Password objects. All valid entries are returned as a list.
   *
   * @return a List of Password objects representing the stored password entries.
   */
  @Override
  public List&lt;Password&gt; readAll() {
<span class="fc" id="L180">    List&lt;Password&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L181">    File file = new File(FILE);</span>

<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (!file.exists()) {</span>
<span class="fc" id="L184">      return list;</span>
    }

<span class="fc" id="L187">    try (BufferedReader reader = new BufferedReader(new FileReader(file))) {</span>
      String line;

<span class="fc bfc" id="L190" title="All 2 branches covered.">      while ((line = reader.readLine()) != null) {</span>
        try {
          // Decrypt the line
<span class="fc" id="L193">          String decrypted = EncryptionUtil.decrypt(line, masterPassword);</span>
<span class="fc" id="L194">          String[] parts = decrypted.split(&quot;,&quot;);</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">          if (parts.length == 3) {</span>
<span class="fc" id="L197">            list.add(new Password(parts[0], parts[1], parts[2]));</span>
          }
<span class="fc" id="L199">        } catch (Exception e) {</span>
          // Skip lines that cannot be decrypted
<span class="fc" id="L201">          System.out.println(&quot;Warning: Could not decrypt a password entry.&quot;);</span>
<span class="fc" id="L202">        }</span>
      }
<span class="nc" id="L204">    } catch (IOException e) {</span>
<span class="nc" id="L205">      System.out.println(&quot;Error reading password file: &quot; + e.getMessage());</span>
<span class="fc" id="L206">    }</span>

<span class="fc" id="L208">    return list;</span>
  }

  /**
   * @brief Writes the list of password entries to the file.
   *
   * This method clears the existing content of the file and writes all password entries
   * from the provided list, encrypting each entry.
   *
   * @param list a List of Password objects to be written to the file.
   */
  @Override
  public void writeAll(List&lt;Password&gt; list) {
<span class="fc" id="L221">    try (BufferedWriter writer = new BufferedWriter(new FileWriter(FILE))) {</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">      for (Password p : list) {</span>
<span class="fc" id="L223">        String data = p.getService() + &quot;,&quot; + p.getUsername() + &quot;,&quot; + p.getPassword();</span>

        try {
          // Encrypt the data
<span class="fc" id="L227">          String encrypted = EncryptionUtil.encrypt(data, masterPassword);</span>
<span class="fc" id="L228">          writer.write(encrypted);</span>
<span class="fc" id="L229">          writer.newLine();</span>
<span class="nc" id="L230">        } catch (Exception e) {</span>
<span class="nc" id="L231">          System.out.println(&quot;Error encrypting password for &quot; + p.getService() + &quot;: &quot; + e.getMessage());</span>
<span class="fc" id="L232">        }</span>
<span class="fc" id="L233">      }</span>
<span class="fc" id="L234">    } catch (IOException e) {</span>
<span class="fc" id="L235">      System.out.println(&quot;Error writing to password file: &quot; + e.getMessage());</span>
<span class="fc" id="L236">    }</span>
<span class="fc" id="L237">  }</span>

  // ========== XOR LINKED LIST FOR AUDIT LOG ==========

  /**
   * @brief XOR Linked List implementation for efficient storage audit log.
   * @details Uses XOR concept to store both prev and next pointers efficiently.
   * In Java, we simulate XOR behavior since we don't have direct memory access.
   *
   * Time Complexity:
   * - insert: O(1)
   * - traverse: O(n)
   * - delete: O(n)
   *
   * Space Complexity: O(n)
   */
  public static class XORLinkedList {
    /**
     * @brief Node for XOR Linked List.
     * In a true XOR linked list, npx would contain XOR of prev and next addresses.
     * In Java, we maintain references directly but follow XOR traversal logic.
     */
    private static class Node {
      String operation; // &quot;ADD&quot;, &quot;UPDATE&quot;, &quot;DELETE&quot;, &quot;VIEW&quot;
      String service;
      long timestamp;
      Node prev; // Previous node
      Node next; // Next node

<span class="fc" id="L266">      Node(String operation, String service) {</span>
<span class="fc" id="L267">        this.operation = operation;</span>
<span class="fc" id="L268">        this.service = service;</span>
<span class="fc" id="L269">        this.timestamp = System.currentTimeMillis();</span>
<span class="fc" id="L270">        this.prev = null;</span>
<span class="fc" id="L271">        this.next = null;</span>
<span class="fc" id="L272">      }</span>
    }

    private Node head;
    private Node tail;
    private int size;

    /**
     * @brief Constructor initializes empty XOR linked list.
     */
<span class="fc" id="L282">    public XORLinkedList() {</span>
<span class="fc" id="L283">      this.head = null;</span>
<span class="fc" id="L284">      this.tail = null;</span>
<span class="fc" id="L285">      this.size = 0;</span>
<span class="fc" id="L286">    }</span>

    /**
     * @brief Inserts a new audit entry at the end.
     *
     * @param operation Type of operation
     * @param service Service name
     */
    public void insert(String operation, String service) {
<span class="fc" id="L295">      Node newNode = new Node(operation, service);</span>

<span class="fc bfc" id="L297" title="All 2 branches covered.">      if (head == null) {</span>
<span class="fc" id="L298">        head = newNode;</span>
<span class="fc" id="L299">        tail = newNode;</span>
      } else {
<span class="fc" id="L301">        newNode.prev = tail;</span>
<span class="fc" id="L302">        tail.next = newNode;</span>
<span class="fc" id="L303">        tail = newNode;</span>
      }

<span class="fc" id="L306">      size++;</span>
<span class="fc" id="L307">    }</span>

    /**
     * @brief Traverses the list forward and returns all entries.
     *
     * @return List of audit log entries
     */
    public List&lt;String&gt; traverse() {
<span class="fc" id="L315">      List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L316">      Node curr = head;</span>

<span class="fc bfc" id="L318" title="All 2 branches covered.">      while (curr != null) {</span>
<span class="fc" id="L319">        result.add(curr.operation + &quot;: &quot; + curr.service +</span>
                   &quot; (at &quot; + new java.util.Date(curr.timestamp) + &quot;)&quot;);
<span class="fc" id="L321">        curr = curr.next;</span>
      }

<span class="fc" id="L324">      return result;</span>
    }

    /**
     * @brief Returns the number of audit entries.
     *
     * @return Size of audit log
     */
    public int size() {
<span class="fc" id="L333">      return size;</span>
    }

    /**
     * @brief Clears all audit entries.
     */
    public void clear() {
<span class="fc" id="L340">      head = null;</span>
<span class="fc" id="L341">      tail = null;</span>
<span class="fc" id="L342">      size = 0;</span>
<span class="fc" id="L343">    }</span>

    /**
     * @brief Gets the most recent audit entries.
     *
     * @param count Number of recent entries to retrieve
     * @return List of recent audit entries
     */
    public List&lt;String&gt; getRecentEntries(int count) {
<span class="fc" id="L352">      List&lt;String&gt; all = traverse();</span>
<span class="fc" id="L353">      int start = Math.max(0, all.size() - count);</span>
<span class="fc" id="L354">      return all.subList(start, all.size());</span>
    }
  }

  /**
   * @brief Audit log using XOR linked list.
   */
<span class="fc" id="L361">  private final XORLinkedList auditLog = new XORLinkedList();</span>

  /**
   * @brief Records an operation in the audit log.
   *
   * @param operation Type of operation
   * @param service Service name
   */
  public void recordAudit(String operation, String service) {
<span class="fc" id="L370">    auditLog.insert(operation, service);</span>
<span class="fc" id="L371">  }</span>

  /**
   * @brief Gets all audit log entries.
   *
   * @return List of audit entries
   */
  public List&lt;String&gt; getAuditLog() {
<span class="fc" id="L379">    return auditLog.traverse();</span>
  }

  /**
   * @brief Gets recent audit log entries.
   *
   * @param count Number of entries
   * @return List of recent entries
   */
  public List&lt;String&gt; getRecentAuditLog(int count) {
<span class="fc" id="L389">    return auditLog.getRecentEntries(count);</span>
  }

  /**
   * @brief Gets audit log size.
   *
   * @return Number of audit entries
   */
  public int getAuditLogSize() {
<span class="fc" id="L398">    return auditLog.size();</span>
  }

  /**
   * @brief Clears audit log.
   */
  public void clearAuditLog() {
<span class="fc" id="L405">    auditLog.clear();</span>
<span class="fc" id="L406">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>