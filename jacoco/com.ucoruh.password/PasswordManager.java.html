<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PasswordManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">password-app</a> &gt; <a href="index.source.html" class="el_package">com.ucoruh.password</a> &gt; <span class="el_source">PasswordManager.java</span></div><h1>PasswordManager.java</h1><pre class="source lang-java linenums">/**
 * @file PasswordManager.java
 * @package com.ucoruh.password
 * @class PasswordManager
 * @brief Main class for the Password Manager application.
 * @author Password Manager Team
 * @version 1.0
 *
 * Manages secure storage and retrieval of credentials using a master password.
 * Includes advanced data structures: Sparse Matrix for access pattern tracking.
 */
package com.ucoruh.password;

import java.io.PrintStream;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Scanner;
import java.util.Set;
import java.util.Stack;
import java.util.stream.Collectors;

/**
 * @brief Main class for the Password Manager application.
 */
public class PasswordManager {
  /**
   * @brief Stores the association between account names and their corresponding passwords.
   *
   * Uses custom hash table implementation with chaining collision resolution.
   */
  private final CustomHashTable&lt;String, String&gt; credentials;

  /**
   * @brief The master password used for authentication.
   *
   * This final field stores the master password that is utilized for user authentication and securing the credentials.
   */
  private final String masterPassword;

  /**
   * @brief The storage implementation for passwords.
   */
  private final InterfacePasswordStorage storage;

  /**
   * @brief Access pattern tracking using sparse matrix.
   */
  private final AccessMatrix accessMatrix;

  /**
   * @brief Undo stack for command pattern.
   */
  private final CommandStack undoStack;

  /**
   * @brief Service dependency graph.
   */
  private final ServiceGraph serviceGraph;

  /**
   * @brief Redo stack for command pattern.
   */
  private final CommandStack redoStack;

  /**
   * @brief Pending operations queue.
   */
  private final PendingOperationsQueue operationsQueue;

  /**
   * @brief Constructor initializing the manager with a master password.
   *
   * Initializes the credentials map and loads stored credentials.
   *
   * @param masterPassword Master password used for encryption/decryption.
   */
<span class="fc" id="L86">  public PasswordManager(String masterPassword) {</span>
<span class="fc" id="L87">    this.masterPassword = masterPassword;</span>
<span class="fc" id="L88">    this.credentials = new CustomHashTable&lt;&gt;();</span>
<span class="fc" id="L89">    this.storage = PasswordStorageFactory.create(StorageType.FILE, masterPassword);</span>
<span class="fc" id="L90">    this.accessMatrix = new AccessMatrix();</span>
<span class="fc" id="L91">    this.undoStack = new CommandStack();</span>
<span class="fc" id="L92">    this.redoStack = new CommandStack();</span>
<span class="fc" id="L93">    this.serviceGraph = new ServiceGraph();</span>
<span class="fc" id="L94">    this.operationsQueue = new PendingOperationsQueue();</span>
<span class="fc" id="L95">    loadCredentials();</span>
<span class="fc" id="L96">  }</span>

  /**
   * @brief Constructor with specified storage type.
   *
   * @param masterPassword Master password used for encryption/decryption.
   * @param storageType The type of storage to use.
   */
<span class="fc" id="L104">  public PasswordManager(String masterPassword, StorageType storageType) {</span>
<span class="fc" id="L105">    this.masterPassword = masterPassword;</span>
<span class="fc" id="L106">    this.credentials = new CustomHashTable&lt;&gt;();</span>
<span class="fc" id="L107">    this.storage = PasswordStorageFactory.create(storageType, masterPassword);</span>
<span class="fc" id="L108">    this.accessMatrix = new AccessMatrix();</span>
<span class="fc" id="L109">    this.undoStack = new CommandStack();</span>
<span class="fc" id="L110">    this.redoStack = new CommandStack();</span>
<span class="fc" id="L111">    this.serviceGraph = new ServiceGraph();</span>
<span class="fc" id="L112">    this.operationsQueue = new PendingOperationsQueue();</span>
<span class="fc" id="L113">    loadCredentials();</span>
<span class="fc" id="L114">  }</span>

  /**
   * @brief Loads credentials from storage.
   */
  private void loadCredentials() {
<span class="fc" id="L120">    List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L121">    credentials.clear();</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">    for (Password p : passwordList) {</span>
<span class="fc" id="L124">      credentials.put(p.getService(), p.getPassword());</span>
<span class="fc" id="L125">    }</span>
<span class="fc" id="L126">  }</span>

  /**
   * @brief Adds a new credential.
   *
   * Inserts the credential for the given account into the internal storage and saves it.
   *
   * @param account Account name.
   * @param password Password for the account.
   */
  public void addCredential(String account, String password) {
    // Get old password for undo
<span class="fc" id="L138">    String oldPassword = credentials.get(account);</span>
<span class="fc" id="L139">    credentials.put(account, password);</span>
    // Create a password list and save it
<span class="fc" id="L141">    List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L142">    boolean updated = false;</span>

    // Check if the account already exists
<span class="fc bfc" id="L145" title="All 2 branches covered.">    for (Password p : passwordList) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">      if (p.getService().equalsIgnoreCase(account)) {</span>
<span class="fc" id="L147">        p.setPassword(password);</span>
<span class="fc" id="L148">        updated = true;</span>
<span class="fc" id="L149">        break;</span>
      }
<span class="fc" id="L151">    }</span>

    // If not found, add new entry
<span class="fc bfc" id="L154" title="All 2 branches covered.">    if (!updated) {</span>
<span class="fc" id="L155">      passwordList.add(new Password(account, &quot;default_user&quot;, password));</span>
    }

<span class="fc" id="L158">    storage.writeAll(passwordList);</span>

    // Add command to undo stack
<span class="fc bfc" id="L161" title="All 2 branches covered.">    if (oldPassword == null) {</span>
      // New credential - undo should delete it
<span class="fc" id="L163">      undoStack.push(new AddCredentialCommand(account, password));</span>
    } else {
      // Update credential - undo should restore old password
<span class="fc" id="L166">      undoStack.push(new UpdateCredentialCommand(account, oldPassword, password));</span>
    }

    // Clear redo stack on new action
<span class="fc" id="L170">    redoStack.clear();</span>
<span class="fc" id="L171">  }</span>

  /**
   * @brief Retrieves a credential.
   *
   * Fetches the password associated with the specified account.
   *
   * @param account Account name.
   * @return Password if account exists; otherwise, returns null.
   */
  public String getCredential(String account) {
    // Reload credentials to ensure we have the latest
<span class="fc" id="L183">    loadCredentials();</span>
    // Record access in matrix
<span class="fc" id="L185">    recordServiceAccess(account);</span>
<span class="fc" id="L186">    return credentials.get(account);</span>
  }

  /**
   * @brief Records a service access in the access matrix.
   *
   * @param service Service name
   */
  private void recordServiceAccess(String service) {
<span class="fc" id="L195">    int hour = LocalDateTime.now().getHour();</span>
<span class="fc" id="L196">    accessMatrix.recordAccess(service, hour);</span>
<span class="fc" id="L197">  }</span>

  /**
   * @brief Gets access pattern for a specific service.
   *
   * @param service Service name
   * @return Map of hour to access count
   */
  public Map&lt;Integer, Integer&gt; getAccessPattern(String service) {
<span class="fc" id="L206">    return accessMatrix.getAccessPattern(service);</span>
  }

  /**
   * @brief Gets the most accessed services.
   *
   * @param topN Number of top services to return
   * @return List of service names sorted by access count
   */
  public List&lt;String&gt; getMostAccessedServices(int topN) {
<span class="fc" id="L216">    return accessMatrix.getMostAccessedServices(topN);</span>
  }

  /**
   * @brief Gets total access count for a service.
   *
   * @param service Service name
   * @return Total number of accesses
   */
  public int getTotalAccessCount(String service) {
<span class="fc" id="L226">    return accessMatrix.getTotalAccessCount(service);</span>
  }

  // ========== UNDO/REDO OPERATIONS ==========

  /**
   * @brief Undoes the last operation.
   *
   * @return true if undo was successful, false if nothing to undo
   */
  public boolean undo() {
<span class="fc bfc" id="L237" title="All 2 branches covered.">    if (undoStack.isEmpty()) {</span>
<span class="fc" id="L238">      return false;</span>
    }

<span class="fc" id="L241">    Command cmd = undoStack.pop();</span>
<span class="fc" id="L242">    cmd.undo();</span>
<span class="fc" id="L243">    redoStack.push(cmd);</span>
<span class="fc" id="L244">    return true;</span>
  }

  /**
   * @brief Redoes the last undone operation.
   *
   * @return true if redo was successful, false if nothing to redo
   */
  public boolean redo() {
<span class="fc bfc" id="L253" title="All 2 branches covered.">    if (redoStack.isEmpty()) {</span>
<span class="fc" id="L254">      return false;</span>
    }

<span class="fc" id="L257">    Command cmd = redoStack.pop();</span>
<span class="fc" id="L258">    cmd.execute();</span>
<span class="fc" id="L259">    undoStack.push(cmd);</span>
<span class="fc" id="L260">    return true;</span>
  }

  /**
   * @brief Checks if undo is available.
   *
   * @return true if there are operations to undo
   */
  public boolean canUndo() {
<span class="fc bfc" id="L269" title="All 2 branches covered.">    return !undoStack.isEmpty();</span>
  }

  /**
   * @brief Checks if redo is available.
   *
   * @return true if there are operations to redo
   */
  public boolean canRedo() {
<span class="fc bfc" id="L278" title="All 2 branches covered.">    return !redoStack.isEmpty();</span>
  }

  /**
   * @brief Displays the interactive menu and processes user input.
   *
   * Uses dependency injection for Scanner and PrintStream to enable unit testing.
   * Provides options to add, retrieve credentials, generate passwords, or exit.
   *
   * @param scanner The Scanner object for reading user input.
   * @param out The PrintStream object for writing output.
   */
  public void menu(Scanner scanner, PrintStream out) {
<span class="fc" id="L291">    boolean back = false;</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">    while (!back) {</span>
<span class="fc" id="L294">      out.println(&quot;\n==== PASSWORD STORAGE MENU ====&quot;);</span>
<span class="fc" id="L295">      out.println(&quot;1. Add New Password&quot;);</span>
<span class="fc" id="L296">      out.println(&quot;2. View All Passwords&quot;);</span>
<span class="fc" id="L297">      out.println(&quot;3. Update Password&quot;);</span>
<span class="fc" id="L298">      out.println(&quot;4. Delete Password&quot;);</span>
<span class="fc" id="L299">      out.println(&quot;5. Generate and Save Password&quot;);</span>
<span class="fc" id="L300">      out.println(&quot;0. Back to Main Menu&quot;);</span>
<span class="fc" id="L301">      out.print(&quot;Your choice: &quot;);</span>
<span class="fc" id="L302">      String input = scanner.nextLine();</span>

      try {
<span class="fc" id="L305">        int choice = Integer.parseInt(input);</span>

<span class="fc bfc" id="L307" title="All 7 branches covered.">        switch (choice) {</span>
          case 1:
<span class="fc" id="L309">            storage.add(scanner);</span>
<span class="fc" id="L310">            break;</span>

          case 2:
<span class="fc" id="L313">            storage.view();</span>
<span class="fc" id="L314">            break;</span>

          case 3:
<span class="fc" id="L317">            storage.update(scanner);</span>
<span class="fc" id="L318">            break;</span>

          case 4:
<span class="fc" id="L321">            storage.delete(scanner);</span>
<span class="fc" id="L322">            break;</span>

          case 5:
<span class="fc" id="L325">            generateAndSavePassword(scanner, out);</span>
<span class="fc" id="L326">            break;</span>

          case 0:
<span class="fc" id="L329">            back = true;</span>
<span class="fc" id="L330">            break;</span>

          default:
<span class="fc" id="L333">            out.println(&quot;Invalid choice.&quot;);</span>
            break;
        }

        // Reload credentials after operations
<span class="fc" id="L338">        loadCredentials();</span>
<span class="fc" id="L339">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L340">        out.println(&quot;Invalid number.&quot;);</span>
<span class="fc" id="L341">      }</span>
<span class="fc" id="L342">    }</span>
<span class="fc" id="L343">  }</span>

  /**
   * @brief Generates a new password and saves it for a service.
   *
   * @param scanner The Scanner object for user input.
   * @param out The PrintStream object for output.
   */
  private void generateAndSavePassword(Scanner scanner, PrintStream out) {
<span class="fc" id="L352">    out.print(&quot;Enter service name: &quot;);</span>
<span class="fc" id="L353">    String service = scanner.nextLine();</span>
<span class="fc" id="L354">    out.print(&quot;Enter username: &quot;);</span>
<span class="fc" id="L355">    String username = scanner.nextLine();</span>
<span class="fc" id="L356">    out.print(&quot;Enter desired password length: &quot;);</span>

    try {
<span class="fc" id="L359">      int length = Integer.parseInt(scanner.nextLine());</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">      if (length &lt;= 0) {</span>
<span class="fc" id="L362">        out.println(&quot;Password length must be greater than 0.&quot;);</span>
<span class="fc" id="L363">        return;</span>
      }

<span class="fc" id="L366">      String password = PasswordGenerator.generatePassword(length);</span>
<span class="fc" id="L367">      out.println(&quot;Generated Password: &quot; + password);</span>
<span class="fc" id="L368">      List&lt;Password&gt; passwords = storage.readAll();</span>
<span class="fc" id="L369">      boolean updated = false;</span>

      // Check if service already exists
<span class="fc bfc" id="L372" title="All 2 branches covered.">      for (Password p : passwords) {</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">        if (p.getService().equalsIgnoreCase(service)) {</span>
<span class="fc" id="L374">          p.setUsername(username);</span>
<span class="fc" id="L375">          p.setPassword(password);</span>
<span class="fc" id="L376">          updated = true;</span>
<span class="fc" id="L377">          break;</span>
        }
<span class="fc" id="L379">      }</span>

      // If not found, add new entry
<span class="fc bfc" id="L382" title="All 2 branches covered.">      if (!updated) {</span>
<span class="fc" id="L383">        passwords.add(new Password(service, username, password));</span>
      }

<span class="fc" id="L386">      storage.writeAll(passwords);</span>
<span class="fc" id="L387">      credentials.put(service, password);</span>
<span class="fc" id="L388">      out.println(&quot;Password saved successfully.&quot;);</span>
<span class="fc" id="L389">    } catch (NumberFormatException e) {</span>
<span class="fc" id="L390">      out.println(&quot;Invalid number.&quot;);</span>
<span class="fc" id="L391">    }</span>
<span class="fc" id="L392">  }</span>

  /**
   * @brief Runs the application using the provided Scanner and PrintStream.
   *
   * Initiates the application by requesting the master password and
   * then invoking the interactive menu.
   *
   * @param scanner Scanner for user input.
   * @param out PrintStream for output.
   */
  public static void runApp(Scanner scanner, PrintStream out) {
<span class="fc" id="L404">    out.print(&quot;Enter master password: &quot;);</span>
<span class="fc" id="L405">    String masterPwd = scanner.nextLine();</span>
<span class="fc" id="L406">    PasswordManager pm = new PasswordManager(masterPwd);</span>
<span class="fc" id="L407">    pm.menu(scanner, out);</span>
<span class="fc" id="L408">  }</span>

  /**
   * @brief Main method to launch the console application.
   *
   * Entry point of the application. Initializes input and output streams,
   * then invokes the runApp method.
   *
   * @param args Command-line arguments.
   */
  public static void main(String[] args) {
<span class="fc" id="L419">    Scanner scanner = new Scanner(System.in);</span>
<span class="fc" id="L420">    runApp(scanner, System.out);</span>
<span class="fc" id="L421">    scanner.close();</span>
<span class="fc" id="L422">  }</span>

  // ========== INNER CLASSES - DATA STRUCTURES ==========

  /**
   * @brief Sparse Matrix implementation for tracking service access patterns.
   *
   * Uses a HashMap-based approach where only non-zero entries are stored.
   * Matrix dimensions: Service (rows) Ã— Hour of Day (columns, 0-23)
   *
   * Time Complexity:
   * - recordAccess: O(1)
   * - getAccessPattern: O(1)
   * - getMostAccessedServices: O(n log n) where n is number of services
   *
   * Space Complexity: O(k) where k is number of non-zero entries
   */
  private static class AccessMatrix {
    /**
     * @brief Nested map: service -&gt; (hour -&gt; access count)
     */
    private final Map&lt;String, Map&lt;Integer, Integer&gt;&gt; matrix;

    /**
     * @brief Constructor initializes empty matrix.
     */
<span class="fc" id="L448">    public AccessMatrix() {</span>
<span class="fc" id="L449">      this.matrix = new HashMap&lt;&gt;();</span>
<span class="fc" id="L450">    }</span>

    /**
     * @brief Records an access to a service at a specific hour.
     *
     * @param service Service name
     * @param hour Hour of day (0-23)
     */
    public void recordAccess(String service, int hour) {
<span class="fc bfc" id="L459" title="All 6 branches covered.">      if (service == null || hour &lt; 0 || hour &gt; 23) {</span>
<span class="fc" id="L460">        return; // Validate input</span>
      }

<span class="fc" id="L463">      matrix.putIfAbsent(service, new HashMap&lt;&gt;());</span>
<span class="fc" id="L464">      Map&lt;Integer, Integer&gt; hourMap = matrix.get(service);</span>
<span class="fc" id="L465">      hourMap.put(hour, hourMap.getOrDefault(hour, 0) + 1);</span>
<span class="fc" id="L466">    }</span>

    /**
     * @brief Gets access pattern for a specific service.
     *
     * @param service Service name
     * @return Map of hour to access count (empty if service not found)
     */
    public Map&lt;Integer, Integer&gt; getAccessPattern(String service) {
<span class="fc" id="L475">      return matrix.getOrDefault(service, Collections.emptyMap());</span>
    }

    /**
     * @brief Gets total access count for a service across all hours.
     *
     * @param service Service name
     * @return Total access count
     */
    public int getTotalAccessCount(String service) {
<span class="fc" id="L485">      Map&lt;Integer, Integer&gt; pattern = matrix.get(service);</span>

<span class="fc bfc" id="L487" title="All 2 branches covered.">      if (pattern == null) {</span>
<span class="fc" id="L488">        return 0;</span>
      }

<span class="fc" id="L491">      return pattern.values().stream().mapToInt(Integer::intValue).sum();</span>
    }

    /**
     * @brief Gets the most accessed services sorted by total access count.
     *
     * @param topN Number of top services to return
     * @return List of service names sorted by access count (descending)
     */
    public List&lt;String&gt; getMostAccessedServices(int topN) {
<span class="fc bfc" id="L501" title="All 2 branches covered.">      if (topN &lt;= 0) {</span>
<span class="fc" id="L502">        return Collections.emptyList();</span>
      }

      // Create list of (service, totalCount) pairs
<span class="fc" id="L506">      List&lt;Map.Entry&lt;String, Integer&gt;&gt; serviceAccessList = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L508" title="All 2 branches covered.">      for (String service : matrix.keySet()) {</span>
<span class="fc" id="L509">        int totalCount = getTotalAccessCount(service);</span>
<span class="fc" id="L510">        serviceAccessList.add(Map.entry(service, totalCount));</span>
<span class="fc" id="L511">      }</span>

      // Sort by count descending
<span class="fc" id="L514">      serviceAccessList.sort(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed());</span>
      // Return top N service names
<span class="fc" id="L516">      return serviceAccessList.stream()</span>
<span class="fc" id="L517">             .limit(topN)</span>
<span class="fc" id="L518">             .map(Map.Entry::getKey)</span>
<span class="fc" id="L519">             .collect(Collectors.toList());</span>
    }

    /**
     * @brief Gets all services tracked in the matrix.
     *
     * @return List of service names
     */
    public List&lt;String&gt; getAllServices() {
<span class="fc" id="L528">      return new ArrayList&lt;&gt;(matrix.keySet());</span>
    }

    /**
     * @brief Clears all access data.
     */
    public void clear() {
<span class="fc" id="L535">      matrix.clear();</span>
<span class="fc" id="L536">    }</span>

    /**
     * @brief Gets the number of services tracked.
     *
     * @return Number of services
     */
    public int size() {
<span class="fc" id="L544">      return matrix.size();</span>
    }
  }

  // ========== CUSTOM HASH TABLE ==========

  /**
   * @brief Custom Hash Table implementation with chaining collision resolution.
   *
   * This implementation uses separate chaining to handle collisions.
   * Provides O(1) average case for put, get, and remove operations.
   *
   * Time Complexity:
   * - put: O(1) average, O(n) worst case
   * - get: O(1) average, O(n) worst case
   * - remove: O(1) average, O(n) worst case
   * - resize: O(n) where n is number of entries
   *
   * Space Complexity: O(n) where n is number of entries
   *
   * @param &lt;K&gt; Key type
   * @param &lt;V&gt; Value type
   */
  private static class CustomHashTable&lt;K, V&gt; {
    /**
     * @brief Entry node for hash table bucket.
     */
    private static class Entry&lt;K, V&gt; {
      /** @brief The key of this entry */
      final K key;
      /** @brief The value associated with the key */
      V value;
      /** @brief Reference to the next entry in the chain */
      Entry&lt;K, V&gt; next;

      /**
       * @brief Constructs an entry with given key and value.
       * @param key The key
       * @param value The value
       */
<span class="fc" id="L584">      Entry(K key, V value) {</span>
<span class="fc" id="L585">        this.key = key;</span>
<span class="fc" id="L586">        this.value = value;</span>
<span class="fc" id="L587">        this.next = null;</span>
<span class="fc" id="L588">      }</span>
    }

    /** @brief Array of buckets for the hash table */
    private Entry&lt;K, V&gt;[] buckets;
    /** @brief Current number of entries in the hash table */
    private int size;
    /** @brief Current capacity of the hash table */
    private int capacity;
    /** @brief Default initial capacity */
    private static final int DEFAULT_CAPACITY = 16;
    /** @brief Load factor threshold for resizing */
    private static final double LOAD_FACTOR_THRESHOLD = 0.75;
    /** @brief Count of collisions that have occurred */
    private int collisionCount;

    /**
     * @brief Constructor initializes hash table with default capacity.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L608">    public CustomHashTable() {</span>
<span class="fc" id="L609">      this.capacity = DEFAULT_CAPACITY;</span>
<span class="fc" id="L610">      this.buckets = new Entry[capacity];</span>
<span class="fc" id="L611">      this.size = 0;</span>
<span class="fc" id="L612">      this.collisionCount = 0;</span>
<span class="fc" id="L613">    }</span>

    /**
     * @brief Constructor with specified initial capacity.
     *
     * @param initialCapacity Initial capacity
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L621">    public CustomHashTable(int initialCapacity) {</span>
<span class="fc" id="L622">      this.capacity = initialCapacity;</span>
<span class="fc" id="L623">      this.buckets = new Entry[capacity];</span>
<span class="fc" id="L624">      this.size = 0;</span>
<span class="fc" id="L625">      this.collisionCount = 0;</span>
<span class="fc" id="L626">    }</span>

    /**
     * @brief Computes hash for a key.
     *
     * @param key Key to hash
     * @return Hash value
     */
    private int hash(K key) {
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">      if (key == null) {</span>
<span class="nc" id="L636">        return 0;</span>
      }

<span class="fc" id="L639">      return Math.abs(key.hashCode() % capacity);</span>
    }

    /**
     * @brief Inserts or updates a key-value pair.
     *
     * @param key Key
     * @param value Value
     * @return Previous value if key existed, null otherwise
     */
    public V put(K key, V value) {
<span class="fc bfc" id="L650" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L651">        throw new IllegalArgumentException(&quot;Key cannot be null&quot;);</span>
      }

      // Check if resize is needed
<span class="fc bfc" id="L655" title="All 2 branches covered.">      if (getLoadFactor() &gt;= LOAD_FACTOR_THRESHOLD) {</span>
<span class="fc" id="L656">        resize();</span>
      }

<span class="fc" id="L659">      int index = hash(key);</span>
<span class="fc" id="L660">      Entry&lt;K, V&gt; entry = buckets[index];</span>

      // Check if key already exists
<span class="fc bfc" id="L663" title="All 2 branches covered.">      while (entry != null) {</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        if (entry.key.equals(key)) {</span>
<span class="fc" id="L665">          V oldValue = entry.value;</span>
<span class="fc" id="L666">          entry.value = value;</span>
<span class="fc" id="L667">          return oldValue;</span>
        }

<span class="fc" id="L670">        entry = entry.next;</span>
      }

      // Add new entry at the beginning of the chain
<span class="fc" id="L674">      Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, value);</span>
<span class="fc" id="L675">      newEntry.next = buckets[index];</span>

      // Track collision
<span class="fc bfc" id="L678" title="All 2 branches covered.">      if (buckets[index] != null) {</span>
<span class="fc" id="L679">        collisionCount++;</span>
      }

<span class="fc" id="L682">      buckets[index] = newEntry;</span>
<span class="fc" id="L683">      size++;</span>
<span class="fc" id="L684">      return null;</span>
    }

    /**
     * @brief Retrieves value for a key.
     *
     * @param key Key to look up
     * @return Value if found, null otherwise
     */
    public V get(K key) {
<span class="fc bfc" id="L694" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L695">        return null;</span>
      }

<span class="fc" id="L698">      int index = hash(key);</span>
<span class="fc" id="L699">      Entry&lt;K, V&gt; entry = buckets[index];</span>

<span class="fc bfc" id="L701" title="All 2 branches covered.">      while (entry != null) {</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">        if (entry.key.equals(key)) {</span>
<span class="fc" id="L703">          return entry.value;</span>
        }

<span class="fc" id="L706">        entry = entry.next;</span>
      }

<span class="fc" id="L709">      return null;</span>
    }

    /**
     * @brief Removes a key-value pair.
     *
     * @param key Key to remove
     * @return Value if key existed, null otherwise
     */
    public V remove(K key) {
<span class="fc bfc" id="L719" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L720">        return null;</span>
      }

<span class="fc" id="L723">      int index = hash(key);</span>
<span class="fc" id="L724">      Entry&lt;K, V&gt; entry = buckets[index];</span>
<span class="fc" id="L725">      Entry&lt;K, V&gt; prev = null;</span>

<span class="fc bfc" id="L727" title="All 2 branches covered.">      while (entry != null) {</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (entry.key.equals(key)) {</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">          if (prev == null) {</span>
<span class="fc" id="L730">            buckets[index] = entry.next;</span>
          } else {
<span class="nc" id="L732">            prev.next = entry.next;</span>
          }

<span class="fc" id="L735">          size--;</span>
<span class="fc" id="L736">          return entry.value;</span>
        }

<span class="nc" id="L739">        prev = entry;</span>
<span class="nc" id="L740">        entry = entry.next;</span>
      }

<span class="fc" id="L743">      return null;</span>
    }

    /**
     * @brief Checks if key exists.
     *
     * @param key Key to check
     * @return true if key exists
     */
    public boolean containsKey(K key) {
<span class="fc bfc" id="L753" title="All 2 branches covered.">      return get(key) != null;</span>
    }

    /**
     * @brief Returns number of entries.
     *
     * @return Size
     */
    public int size() {
<span class="fc" id="L762">      return size;</span>
    }

    /**
     * @brief Checks if hash table is empty.
     *
     * @return true if empty
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L771" title="All 2 branches covered.">      return size == 0;</span>
    }

    /**
     * @brief Clears all entries.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void clear() {
<span class="fc" id="L779">      buckets = new Entry[capacity];</span>
<span class="fc" id="L780">      size = 0;</span>
<span class="fc" id="L781">      collisionCount = 0;</span>
<span class="fc" id="L782">    }</span>

    /**
     * @brief Gets current load factor.
     *
     * @return Load factor
     */
    public double getLoadFactor() {
<span class="fc" id="L790">      return (double) size / capacity;</span>
    }

    /**
     * @brief Gets total collision count.
     *
     * @return Collision count
     */
    public int getCollisionCount() {
<span class="fc" id="L799">      return collisionCount;</span>
    }

    /**
     * @brief Gets all keys.
     *
     * @return List of keys
     */
    public List&lt;K&gt; keySet() {
<span class="fc" id="L808">      List&lt;K&gt; keys = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L810" title="All 2 branches covered.">      for (Entry&lt;K, V&gt; bucket : buckets) {</span>
<span class="fc" id="L811">        Entry&lt;K, V&gt; entry = bucket;</span>

<span class="fc bfc" id="L813" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="fc" id="L814">          keys.add(entry.key);</span>
<span class="fc" id="L815">          entry = entry.next;</span>
        }
      }

<span class="fc" id="L819">      return keys;</span>
    }

    /**
     * @brief Gets all values.
     *
     * @return List of values
     */
    public List&lt;V&gt; values() {
<span class="fc" id="L828">      List&lt;V&gt; vals = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L830" title="All 2 branches covered.">      for (Entry&lt;K, V&gt; bucket : buckets) {</span>
<span class="fc" id="L831">        Entry&lt;K, V&gt; entry = bucket;</span>

<span class="fc bfc" id="L833" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="fc" id="L834">          vals.add(entry.value);</span>
<span class="fc" id="L835">          entry = entry.next;</span>
        }
      }

<span class="fc" id="L839">      return vals;</span>
    }

    /**
     * @brief Resizes the hash table when load factor exceeds threshold.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void resize() {
<span class="fc" id="L847">      int newCapacity = capacity * 2;</span>
<span class="fc" id="L848">      Entry&lt;K, V&gt;[] oldBuckets = buckets;</span>
<span class="fc" id="L849">      buckets = new Entry[newCapacity];</span>
<span class="fc" id="L850">      capacity = newCapacity;</span>
<span class="fc" id="L851">      size = 0;</span>
<span class="fc" id="L852">      collisionCount = 0;</span>

      // Rehash all entries
<span class="fc bfc" id="L855" title="All 2 branches covered.">      for (Entry&lt;K, V&gt; bucket : oldBuckets) {</span>
<span class="fc" id="L856">        Entry&lt;K, V&gt; entry = bucket;</span>

<span class="fc bfc" id="L858" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="fc" id="L859">          put(entry.key, entry.value);</span>
<span class="fc" id="L860">          entry = entry.next;</span>
        }
      }
<span class="fc" id="L863">    }</span>
  }

  // ========== HEAP SORT IMPLEMENTATION ==========

  /**
   * @brief Service usage data for sorting.
   */
  private static class ServiceUsage implements Comparable&lt;ServiceUsage&gt; {
    /** @brief The service name */
    private final String service;
    /** @brief The usage count for this service */
    private final int usageCount;

    /**
     * @brief Constructs a ServiceUsage object.
     * @param service The service name
     * @param usageCount The usage count
     */
<span class="fc" id="L882">    public ServiceUsage(String service, int usageCount) {</span>
<span class="fc" id="L883">      this.service = service;</span>
<span class="fc" id="L884">      this.usageCount = usageCount;</span>
<span class="fc" id="L885">    }</span>

    /**
     * @brief Gets the service name.
     * @return The service name
     */
    public String getService() {
<span class="fc" id="L892">      return service;</span>
    }

    /**
     * @brief Gets the usage count.
     * @return The usage count
     */
    public int getUsageCount() {
<span class="fc" id="L900">      return usageCount;</span>
    }

    @Override
    public int compareTo(ServiceUsage other) {
      // Natural order: ascending by usage count
<span class="fc" id="L906">      return Integer.compare(this.usageCount, other.usageCount);</span>
    }
  }

  /**
   * @brief Sorts service usage data using heap sort algorithm.
   *
   * Time Complexity: O(n log n)
   * Space Complexity: O(1) - in-place sorting
   *
   * @param arr Array to sort
   */
  private void heapSort(ServiceUsage[] arr) {
<span class="fc" id="L919">    int n = arr.length;</span>

    // Build max heap
<span class="fc bfc" id="L922" title="All 2 branches covered.">    for (int i = n / 2 - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L923">      heapify(arr, n, i);</span>
    }

    // Extract elements from heap one by one
<span class="fc bfc" id="L927" title="All 2 branches covered.">    for (int i = n - 1; i &gt; 0; i--) {</span>
      // Move current root to end
<span class="fc" id="L929">      ServiceUsage temp = arr[0];</span>
<span class="fc" id="L930">      arr[0] = arr[i];</span>
<span class="fc" id="L931">      arr[i] = temp;</span>
      // Heapify the reduced heap
<span class="fc" id="L933">      heapify(arr, i, 0);</span>
    }
<span class="fc" id="L935">  }</span>

  /**
   * @brief Maintains heap property for a subtree.
   *
   * @param arr Array representing heap
   * @param n Size of heap
   * @param i Root index of subtree
   */
  private void heapify(ServiceUsage[] arr, int n, int i) {
<span class="fc" id="L945">    int largest = i;</span>
<span class="fc" id="L946">    int left = 2 * i + 1;</span>
<span class="fc" id="L947">    int right = 2 * i + 2;</span>

    // Check if left child is larger than root
<span class="fc bfc" id="L950" title="All 4 branches covered.">    if (left &lt; n &amp;&amp; arr[left].compareTo(arr[largest]) &gt; 0) {</span>
<span class="fc" id="L951">      largest = left;</span>
    }

    // Check if right child is larger than current largest
<span class="fc bfc" id="L955" title="All 4 branches covered.">    if (right &lt; n &amp;&amp; arr[right].compareTo(arr[largest]) &gt; 0) {</span>
<span class="fc" id="L956">      largest = right;</span>
    }

    // If largest is not root
<span class="fc bfc" id="L960" title="All 2 branches covered.">    if (largest != i) {</span>
<span class="fc" id="L961">      ServiceUsage swap = arr[i];</span>
<span class="fc" id="L962">      arr[i] = arr[largest];</span>
<span class="fc" id="L963">      arr[largest] = swap;</span>
      // Recursively heapify the affected subtree
<span class="fc" id="L965">      heapify(arr, n, largest);</span>
    }
<span class="fc" id="L967">  }</span>

  /**
   * @brief Gets most used services sorted by usage count using heap sort.
   *
   * Combines access matrix data with heap sort for efficient ranking.
   *
   * @return List of services sorted by usage count
   */
  public List&lt;String&gt; getMostUsedServicesByHeapSort() {
<span class="fc" id="L977">    List&lt;String&gt; services = accessMatrix.getAllServices();</span>

<span class="fc bfc" id="L979" title="All 2 branches covered.">    if (services.isEmpty()) {</span>
<span class="fc" id="L980">      return new ArrayList&lt;&gt;();</span>
    }

    // Create array of service usage
<span class="fc" id="L984">    ServiceUsage[] usageArray = new ServiceUsage[services.size()];</span>

<span class="fc bfc" id="L986" title="All 2 branches covered.">    for (int i = 0; i &lt; services.size(); i++) {</span>
<span class="fc" id="L987">      String service = services.get(i);</span>
<span class="fc" id="L988">      int count = accessMatrix.getTotalAccessCount(service);</span>
<span class="fc" id="L989">      usageArray[i] = new ServiceUsage(service, count);</span>
    }

    // Sort using heap sort (ascending)
<span class="fc" id="L993">    heapSort(usageArray);</span>
    // Reverse to get descending order (most used first)
<span class="fc" id="L995">    List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L997" title="All 2 branches covered.">    for (int i = usageArray.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L998">      ServiceUsage usage = usageArray[i];</span>
<span class="fc" id="L999">      result.add(usage.getService() + &quot; (&quot; + usage.getUsageCount() + &quot; accesses)&quot;);</span>
    }

<span class="fc" id="L1002">    return result;</span>
  }

  // ========== COMMAND PATTERN FOR UNDO/REDO ==========

  /**
   * @brief Command interface for undo/redo operations.
   */
  private interface Command {
    void execute();
    void undo();
  }

  /**
   * @brief Command for adding a new credential.
   */
  private class AddCredentialCommand implements Command {
    private final String account;
    private final String password;

<span class="fc" id="L1022">    AddCredentialCommand(String account, String password) {</span>
<span class="fc" id="L1023">      this.account = account;</span>
<span class="fc" id="L1024">      this.password = password;</span>
<span class="fc" id="L1025">    }</span>

    @Override
    public void execute() {
<span class="fc" id="L1029">      credentials.put(account, password);</span>
<span class="fc" id="L1030">      List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L1031">      passwordList.add(new Password(account, &quot;default_user&quot;, password));</span>
<span class="fc" id="L1032">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1033">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L1037">      credentials.remove(account);</span>
<span class="fc" id="L1038">      List&lt;Password&gt; passwordList = storage.readAll();</span>
<span class="fc" id="L1039">      passwordList.removeIf(p -&gt; p.getService().equalsIgnoreCase(account));</span>
<span class="fc" id="L1040">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1041">    }</span>
  }

  /**
   * @brief Command for updating an existing credential.
   */
  private class UpdateCredentialCommand implements Command {
    private final String account;
    private final String oldPassword;
    private final String newPassword;

<span class="fc" id="L1052">    UpdateCredentialCommand(String account, String oldPassword, String newPassword) {</span>
<span class="fc" id="L1053">      this.account = account;</span>
<span class="fc" id="L1054">      this.oldPassword = oldPassword;</span>
<span class="fc" id="L1055">      this.newPassword = newPassword;</span>
<span class="fc" id="L1056">    }</span>

    @Override
    public void execute() {
<span class="fc" id="L1060">      credentials.put(account, newPassword);</span>
<span class="fc" id="L1061">      List&lt;Password&gt; passwordList = storage.readAll();</span>

<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">      for (Password p : passwordList) {</span>
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">        if (p.getService().equalsIgnoreCase(account)) {</span>
<span class="fc" id="L1065">          p.setPassword(newPassword);</span>
<span class="fc" id="L1066">          break;</span>
        }
<span class="nc" id="L1068">      }</span>

<span class="fc" id="L1070">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1071">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L1075">      credentials.put(account, oldPassword);</span>
<span class="fc" id="L1076">      List&lt;Password&gt; passwordList = storage.readAll();</span>

<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">      for (Password p : passwordList) {</span>
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">        if (p.getService().equalsIgnoreCase(account)) {</span>
<span class="fc" id="L1080">          p.setPassword(oldPassword);</span>
<span class="fc" id="L1081">          break;</span>
        }
<span class="nc" id="L1083">      }</span>

<span class="fc" id="L1085">      storage.writeAll(passwordList);</span>
<span class="fc" id="L1086">    }</span>
  }

  /**
   * @brief Stack implementation for command history.
   *
   * Uses linked list approach for O(1) push/pop operations.
   *
   * Time Complexity:
   * - push: O(1)
   * - pop: O(1)
   * - peek: O(1)
   * - isEmpty: O(1)
   *
   * Space Complexity: O(n) where n is number of commands
   */
  private static class CommandStack {
    /**
     * @brief Node for stack implementation.
     */
    private static class Node {
      /** @brief The command stored in this node */
      Command command;
      /** @brief Reference to the next node */
      Node next;

      /**
       * @brief Constructs a node with the given command.
       * @param command The command to store
       */
<span class="fc" id="L1116">      Node(Command command) {</span>
<span class="fc" id="L1117">        this.command = command;</span>
<span class="fc" id="L1118">        this.next = null;</span>
<span class="fc" id="L1119">      }</span>
    }

    /** @brief Reference to the top of the stack */
    private Node top;
    /** @brief Current number of elements in the stack */
    private int size;

    /**
     * @brief Constructor initializes empty stack.
     */
<span class="fc" id="L1130">    public CommandStack() {</span>
<span class="fc" id="L1131">      this.top = null;</span>
<span class="fc" id="L1132">      this.size = 0;</span>
<span class="fc" id="L1133">    }</span>

    /**
     * @brief Pushes a command onto the stack.
     *
     * @param command Command to push
     */
    public void push(Command command) {
<span class="fc" id="L1141">      Node newNode = new Node(command);</span>
<span class="fc" id="L1142">      newNode.next = top;</span>
<span class="fc" id="L1143">      top = newNode;</span>
<span class="fc" id="L1144">      size++;</span>
<span class="fc" id="L1145">    }</span>

    /**
     * @brief Pops a command from the stack.
     *
     * @return Command from top of stack, or null if empty
     */
    public Command pop() {
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">      if (isEmpty()) {</span>
<span class="nc" id="L1154">        return null;</span>
      }

<span class="fc" id="L1157">      Command command = top.command;</span>
<span class="fc" id="L1158">      top = top.next;</span>
<span class="fc" id="L1159">      size--;</span>
<span class="fc" id="L1160">      return command;</span>
    }

    /**
     * @brief Peeks at the top command without removing it.
     *
     * @return Command from top of stack, or null if empty
     */
    public Command peek() {
<span class="pc bpc" id="L1169" title="1 of 2 branches missed.">      return isEmpty() ? null : top.command;</span>
    }

    /**
     * @brief Checks if stack is empty.
     *
     * @return true if stack has no elements
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L1178" title="All 2 branches covered.">      return top == null;</span>
    }

    /**
     * @brief Gets the size of the stack.
     *
     * @return Number of commands in stack
     */
    public int size() {
<span class="fc" id="L1187">      return size;</span>
    }

    /**
     * @brief Clears all commands from the stack.
     */
    public void clear() {
<span class="fc" id="L1194">      top = null;</span>
<span class="fc" id="L1195">      size = 0;</span>
<span class="fc" id="L1196">    }</span>
  }

  // ========== SERVICE DEPENDENCY GRAPH (BFS, DFS, SCC) ==========

  /**
   * @brief Graph data structure for tracking service dependencies.
   * @details Implements directed graph with BFS, DFS, and Strongly Connected Components (Kosaraju's algorithm).
   *
   * Time Complexity:
   * - addEdge: O(1)
   * - BFS: O(V + E)
   * - DFS: O(V + E)
   * - SCC: O(V + E)
   *
   * Space Complexity: O(V + E)
   */
  public static class ServiceGraph {
    private final Map&lt;String, List&lt;String&gt;&gt; adjacencyList;
    private final Map&lt;String, List&lt;String&gt;&gt; reverseAdjacencyList;

    /**
     * @brief Constructor initializes empty graph.
     */
<span class="fc" id="L1220">    public ServiceGraph() {</span>
<span class="fc" id="L1221">      this.adjacencyList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1222">      this.reverseAdjacencyList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1223">    }</span>

    /**
     * @brief Adds a directed edge from service1 to service2.
     * @details Represents that service1 depends on service2.
     *
     * @param service1 Source service
     * @param service2 Destination service
     */
    public void addEdge(String service1, String service2) {
<span class="fc" id="L1233">      adjacencyList.putIfAbsent(service1, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1234">      adjacencyList.putIfAbsent(service2, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1235">      adjacencyList.get(service1).add(service2);</span>
      // Build reverse graph for SCC
<span class="fc" id="L1237">      reverseAdjacencyList.putIfAbsent(service1, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1238">      reverseAdjacencyList.putIfAbsent(service2, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L1239">      reverseAdjacencyList.get(service2).add(service1);</span>
<span class="fc" id="L1240">    }</span>

    /**
     * @brief Breadth-First Search traversal starting from a service.
     * @details Returns list of services reachable from start in BFS order.
     *
     * Time Complexity: O(V + E)
     * Space Complexity: O(V)
     *
     * @param start Starting service
     * @return List of services in BFS order
     */
    public List&lt;String&gt; bfs(String start) {
<span class="fc bfc" id="L1253" title="All 2 branches covered.">      if (!adjacencyList.containsKey(start)) {</span>
<span class="fc" id="L1254">        return new ArrayList&lt;&gt;();</span>
      }

<span class="fc" id="L1257">      List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1258">      Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1259">      Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L1260">      queue.offer(start);</span>
<span class="fc" id="L1261">      visited.add(start);</span>

<span class="fc bfc" id="L1263" title="All 2 branches covered.">      while (!queue.isEmpty()) {</span>
<span class="fc" id="L1264">        String current = queue.poll();</span>
<span class="fc" id="L1265">        result.add(current);</span>
<span class="fc" id="L1266">        List&lt;String&gt; neighbors = adjacencyList.get(current);</span>

<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">        if (neighbors != null) {</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">          for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1270" title="All 2 branches covered.">            if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1271">              visited.add(neighbor);</span>
<span class="fc" id="L1272">              queue.offer(neighbor);</span>
            }
<span class="fc" id="L1274">          }</span>
        }
<span class="fc" id="L1276">      }</span>

<span class="fc" id="L1278">      return result;</span>
    }

    /**
     * @brief Depth-First Search traversal starting from a service.
     * @details Returns list of services reachable from start in DFS order.
     *
     * Time Complexity: O(V + E)
     * Space Complexity: O(V)
     *
     * @param start Starting service
     * @return List of services in DFS order
     */
    public List&lt;String&gt; dfs(String start) {
<span class="fc bfc" id="L1292" title="All 2 branches covered.">      if (!adjacencyList.containsKey(start)) {</span>
<span class="fc" id="L1293">        return new ArrayList&lt;&gt;();</span>
      }

<span class="fc" id="L1296">      List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1297">      Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1298">      dfsHelper(start, visited, result);</span>
<span class="fc" id="L1299">      return result;</span>
    }

    /**
     * @brief Helper method for DFS traversal.
     *
     * @param current Current service being visited
     * @param visited Set of visited services
     * @param result List to store DFS order
     */
    private void dfsHelper(String current, Set&lt;String&gt; visited, List&lt;String&gt; result) {
<span class="fc" id="L1310">      visited.add(current);</span>
<span class="fc" id="L1311">      result.add(current);</span>
<span class="fc" id="L1312">      List&lt;String&gt; neighbors = adjacencyList.get(current);</span>

<span class="pc bpc" id="L1314" title="1 of 2 branches missed.">      if (neighbors != null) {</span>
<span class="fc bfc" id="L1315" title="All 2 branches covered.">        for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1316" title="All 2 branches covered.">          if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1317">            dfsHelper(neighbor, visited, result);</span>
          }
<span class="fc" id="L1319">        }</span>
      }
<span class="fc" id="L1321">    }</span>

    /**
     * @brief Finds all Strongly Connected Components using Kosaraju's algorithm.
     * @details A SCC is a maximal set of vertices where each vertex is reachable from every other.
     *
     * Algorithm:
     * 1. Perform DFS on original graph to get finish times
     * 2. Perform DFS on reversed graph in decreasing finish time order
     * 3. Each DFS tree in step 2 is a SCC
     *
     * Time Complexity: O(V + E)
     * Space Complexity: O(V)
     *
     * @return List of SCCs, each SCC is a list of services
     */
    public List&lt;List&lt;String&gt;&gt; findStronglyConnectedComponents() {
<span class="fc" id="L1338">      List&lt;List&lt;String&gt;&gt; sccs = new ArrayList&lt;&gt;();</span>
      // Step 1: Get finish times using DFS
<span class="fc" id="L1340">      Stack&lt;String&gt; finishStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L1341">      Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L1343" title="All 2 branches covered.">      for (String service : adjacencyList.keySet()) {</span>
<span class="fc bfc" id="L1344" title="All 2 branches covered.">        if (!visited.contains(service)) {</span>
<span class="fc" id="L1345">          fillFinishStack(service, visited, finishStack);</span>
        }
<span class="fc" id="L1347">      }</span>

      // Step 2: Process vertices in decreasing finish time order on reversed graph
<span class="fc" id="L1350">      visited.clear();</span>

<span class="fc bfc" id="L1352" title="All 2 branches covered.">      while (!finishStack.isEmpty()) {</span>
<span class="fc" id="L1353">        String service = finishStack.pop();</span>

<span class="fc bfc" id="L1355" title="All 2 branches covered.">        if (!visited.contains(service)) {</span>
<span class="fc" id="L1356">          List&lt;String&gt; scc = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1357">          dfsReverse(service, visited, scc);</span>
<span class="fc" id="L1358">          sccs.add(scc);</span>
        }
<span class="fc" id="L1360">      }</span>

<span class="fc" id="L1362">      return sccs;</span>
    }

    /**
     * @brief Fills stack with services in order of finish time.
     *
     * @param current Current service
     * @param visited Set of visited services
     * @param finishStack Stack to store finish order
     */
    private void fillFinishStack(String current, Set&lt;String&gt; visited, Stack&lt;String&gt; finishStack) {
<span class="fc" id="L1373">      visited.add(current);</span>
<span class="fc" id="L1374">      List&lt;String&gt; neighbors = adjacencyList.get(current);</span>

<span class="pc bpc" id="L1376" title="1 of 2 branches missed.">      if (neighbors != null) {</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">        for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1378" title="All 2 branches covered.">          if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1379">            fillFinishStack(neighbor, visited, finishStack);</span>
          }
<span class="fc" id="L1381">        }</span>
      }

<span class="fc" id="L1384">      finishStack.push(current);</span>
<span class="fc" id="L1385">    }</span>

    /**
     * @brief DFS on reversed graph to find a SCC.
     *
     * @param current Current service
     * @param visited Set of visited services
     * @param scc List to store current SCC
     */
    private void dfsReverse(String current, Set&lt;String&gt; visited, List&lt;String&gt; scc) {
<span class="fc" id="L1395">      visited.add(current);</span>
<span class="fc" id="L1396">      scc.add(current);</span>
<span class="fc" id="L1397">      List&lt;String&gt; neighbors = reverseAdjacencyList.get(current);</span>

<span class="pc bpc" id="L1399" title="1 of 2 branches missed.">      if (neighbors != null) {</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">        for (String neighbor : neighbors) {</span>
<span class="fc bfc" id="L1401" title="All 2 branches covered.">          if (!visited.contains(neighbor)) {</span>
<span class="fc" id="L1402">            dfsReverse(neighbor, visited, scc);</span>
          }
<span class="fc" id="L1404">        }</span>
      }
<span class="fc" id="L1406">    }</span>

    /**
     * @brief Gets all services in the graph.
     *
     * @return Set of all service names
     */
    public Set&lt;String&gt; getAllServices() {
<span class="fc" id="L1414">      return new HashSet&lt;&gt;(adjacencyList.keySet());</span>
    }

    /**
     * @brief Gets neighbors of a service.
     *
     * @param service Service name
     * @return List of neighboring services
     */
    public List&lt;String&gt; getNeighbors(String service) {
<span class="fc" id="L1424">      List&lt;String&gt; neighbors = adjacencyList.get(service);</span>
<span class="fc bfc" id="L1425" title="All 2 branches covered.">      return neighbors != null ? new ArrayList&lt;&gt;(neighbors) : new ArrayList&lt;&gt;();</span>
    }

    /**
     * @brief Checks if graph contains a service.
     *
     * @param service Service name
     * @return true if service exists in graph
     */
    public boolean containsService(String service) {
<span class="fc" id="L1435">      return adjacencyList.containsKey(service);</span>
    }

    /**
     * @brief Clears the graph.
     */
    public void clear() {
<span class="fc" id="L1442">      adjacencyList.clear();</span>
<span class="fc" id="L1443">      reverseAdjacencyList.clear();</span>
<span class="fc" id="L1444">    }</span>
  }

  /**
   * @brief Analyzes service dependencies and returns related services.
   * @details Uses BFS to find all services reachable from the given service.
   *
   * @param service Service name
   * @return List of related services
   */
  public List&lt;String&gt; getRelatedServices(String service) {
<span class="fc" id="L1455">    return serviceGraph.bfs(service);</span>
  }

  /**
   * @brief Adds a dependency relationship between two services.
   *
   * @param service1 Source service
   * @param service2 Dependent service
   */
  public void addServiceDependency(String service1, String service2) {
<span class="fc" id="L1465">    serviceGraph.addEdge(service1, service2);</span>
<span class="fc" id="L1466">  }</span>

  /**
   * @brief Gets all strongly connected components in service dependencies.
   *
   * @return List of SCCs
   */
  public List&lt;List&lt;String&gt;&gt; getServiceClusters() {
<span class="fc" id="L1474">    return serviceGraph.findStronglyConnectedComponents();</span>
  }

  /**
   * @brief Gets the service dependency graph.
   *
   * @return ServiceGraph instance
   */
  public ServiceGraph getServiceGraph() {
<span class="fc" id="L1483">    return serviceGraph;</span>
  }

  /**
   * @brief Queues a pending operation.
   *
   * @param operation Operation description
   */
  public void queueOperation(String operation) {
<span class="fc" id="L1492">    operationsQueue.enqueue(operation);</span>
<span class="fc" id="L1493">  }</span>

  /**
   * @brief Processes all pending operations.
   *
   * @return List of processed operations
   */
  public List&lt;String&gt; processPendingOperations() {
<span class="fc" id="L1501">    List&lt;String&gt; processed = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L1503" title="All 2 branches covered.">    while (!operationsQueue.isEmpty()) {</span>
<span class="fc" id="L1504">      processed.add(operationsQueue.dequeue());</span>
    }

<span class="fc" id="L1507">    return processed;</span>
  }

  /**
   * @brief Gets the count of pending operations.
   *
   * @return Number of pending operations
   */
  public int getPendingOperationsCount() {
<span class="fc" id="L1516">    return operationsQueue.size();</span>
  }

  /**
   * @brief Peeks at the next pending operation without removing it.
   *
   * @return Next operation or null if queue is empty
   */
  public String peekNextOperation() {
<span class="fc" id="L1525">    return operationsQueue.peek();</span>
  }

  /**
   * @brief Gets the pending operations queue.
   *
   * @return PendingOperationsQueue instance
   */
  public PendingOperationsQueue getOperationsQueue() {
<span class="fc" id="L1534">    return operationsQueue;</span>
  }

  /**
   * @brief Custom Queue implementation using linked nodes.
   *
   * Implements FIFO (First-In-First-Out) data structure for pending operations.
   */
  public static class PendingOperationsQueue {
    /**
     * @brief Node class for queue elements.
     */
    private static class Node {
      /** @brief The operation stored in this node */
      String operation;
      /** @brief Reference to the next node */
      Node next;

      /**
       * @brief Constructs a node with the given operation.
       * @param operation The operation to store
       */
<span class="fc" id="L1556">      Node(String operation) {</span>
<span class="fc" id="L1557">        this.operation = operation;</span>
<span class="fc" id="L1558">        this.next = null;</span>
<span class="fc" id="L1559">      }</span>
    }

    /** @brief Front of queue (dequeue from here) */
    private Node front;
    /** @brief Rear of queue (enqueue to here) */
    private Node rear;
    /** @brief Current number of elements in the queue */
    private int size;

    /**
     * @brief Constructor initializing empty queue.
     */
<span class="fc" id="L1572">    public PendingOperationsQueue() {</span>
<span class="fc" id="L1573">      this.front = null;</span>
<span class="fc" id="L1574">      this.rear = null;</span>
<span class="fc" id="L1575">      this.size = 0;</span>
<span class="fc" id="L1576">    }</span>

    /**
     * @brief Adds an operation to the rear of the queue.
     *
     * Time complexity: O(1)
     *
     * @param operation Operation to enqueue
     */
    public void enqueue(String operation) {
<span class="fc" id="L1586">      Node newNode = new Node(operation);</span>

<span class="fc bfc" id="L1588" title="All 2 branches covered.">      if (isEmpty()) {</span>
<span class="fc" id="L1589">        front = newNode;</span>
<span class="fc" id="L1590">        rear = newNode;</span>
      } else {
<span class="fc" id="L1592">        rear.next = newNode;</span>
<span class="fc" id="L1593">        rear = newNode;</span>
      }

<span class="fc" id="L1596">      size++;</span>
<span class="fc" id="L1597">    }</span>

    /**
     * @brief Removes and returns the operation from the front of the queue.
     *
     * Time complexity: O(1)
     *
     * @return Front operation, or null if queue is empty
     */
    public String dequeue() {
<span class="fc bfc" id="L1607" title="All 2 branches covered.">      if (isEmpty()) {</span>
<span class="fc" id="L1608">        return null;</span>
      }

<span class="fc" id="L1611">      String operation = front.operation;</span>
<span class="fc" id="L1612">      front = front.next;</span>

<span class="fc bfc" id="L1614" title="All 2 branches covered.">      if (front == null) {</span>
<span class="fc" id="L1615">        rear = null;  // Queue is now empty</span>
      }

<span class="fc" id="L1618">      size--;</span>
<span class="fc" id="L1619">      return operation;</span>
    }

    /**
     * @brief Returns the operation at the front without removing it.
     *
     * Time complexity: O(1)
     *
     * @return Front operation, or null if queue is empty
     */
    public String peek() {
<span class="fc bfc" id="L1630" title="All 2 branches covered.">      if (isEmpty()) {</span>
<span class="fc" id="L1631">        return null;</span>
      }

<span class="fc" id="L1634">      return front.operation;</span>
    }

    /**
     * @brief Checks if the queue is empty.
     *
     * Time complexity: O(1)
     *
     * @return true if queue is empty, false otherwise
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L1645" title="All 2 branches covered.">      return size == 0;</span>
    }

    /**
     * @brief Gets the current size of the queue.
     *
     * Time complexity: O(1)
     *
     * @return Number of operations in the queue
     */
    public int size() {
<span class="fc" id="L1656">      return size;</span>
    }

    /**
     * @brief Clears all operations from the queue.
     *
     * Time complexity: O(1)
     */
    public void clear() {
<span class="fc" id="L1665">      front = null;</span>
<span class="fc" id="L1666">      rear = null;</span>
<span class="fc" id="L1667">      size = 0;</span>
<span class="fc" id="L1668">    }</span>

    /**
     * @brief Gets all operations as a list without removing them.
     *
     * Time complexity: O(n)
     *
     * @return List of all operations in FIFO order
     */
    public List&lt;String&gt; toList() {
<span class="fc" id="L1678">      List&lt;String&gt; operations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1679">      Node current = front;</span>

<span class="fc bfc" id="L1681" title="All 2 branches covered.">      while (current != null) {</span>
<span class="fc" id="L1682">        operations.add(current.operation);</span>
<span class="fc" id="L1683">        current = current.next;</span>
      }

<span class="fc" id="L1686">      return operations;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>